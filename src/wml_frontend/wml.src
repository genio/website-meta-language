#!@PATH_PERL@
eval 'exec @PATH_PERL@ -S $0 ${1+"$@"}'
    if $running_under_some_shell;
##
##  WML -- Website META Language
##
##  Copyright (c) 1996-2001 Ralf S. Engelschall.
##  Copyright (c) 1999-2001 Denis Barbier.
##
##  This program is free software; you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation; either version 2 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program; if not, write to
##
##      Free Software Foundation, Inc.
##      59 Temple Place - Suite 330
##      Boston, MA  02111-1307, USA
##
##  Notice, that ``free software'' addresses the fact that this program
##  is __distributed__ under the term of the GNU General Public License
##  and because of this, it can be redistributed and modified under the
##  conditions of this license, but the software remains __copyrighted__
##  by the author. Don't intermix this with the general meaning of
##  Public Domain software or such a derivated distribution label.
##
##  The author reserves the right to distribute following releases of
##  this program under different conditions or license agreements.
##

use strict;
use warnings;

my $opt_v = -1;

sub verbose
{
    my ( $level, $str ) = @_;

    if ( $opt_v >= $level )
    {
        print STDERR "** WML:Verbose: $str";
    }
}

package WML::WML_F::PassObj;

use Class::XSAccessor (
    constructor => 'new',
    accessors   => +{ map { $_ => $_ } qw( idx cb opt_pass time_ src_cb) }
);

use File::Basename qw/ basename /;
use File::Which qw/ which /;
use IO::All qw/ io /;

*verbose = \&::verbose;

sub precompile
{
    my ( $name, $in ) = @_;

    my $error = '';
    local $SIG{__WARN__} = sub { $error .= $_[0]; };
    local $SIG{__DIE__};

    $in =~ s|exit(\s*\(0\))|return$1|sg;
    $in =~ s|exit(\s*\([^0].*?\))|die$1|sg;
    eval( "no strict; no warnings; package $name; \$main = sub { \@ARGV = \@_; "
            . $in
            . "; return 0; }; package main;" );
    $error = "$@" if ($@);
    my $func = eval("no strict; no warnings; \$${name}::main");

    $@ = $error || '';
    return ( $func, $@ );
}

#   remove escape backslashes
sub unquotearg
{
    my ($arg) = @_;
    $arg =~ s/\\([\$"`])/$1/g;
    return $arg;
}

sub dosource
{
    my ( $pass, $prog, $args ) = @_;
    verbose( 2, "source: $prog $args\n" );
    verbose( 9, "loading: $prog\n" );
    if ( !defined( $pass->src_cb ) )
    {
        my $pkgname = basename($prog);
        if ( $prog !~ m|\A/| )
        {
            $prog = which($prog);
        }
        my $src = io->file($prog)->all;
        verbose( 9,
            "loading: succeeded with $prog (" . length($src) . " bytes)\n" );

        verbose( 9, "precompiling script: pkgname=$pkgname\n" );
        my ( $func, $error ) = precompile( $pkgname, $src );
        if ( $error ne '' )
        {
            verbose( 9, "precompiling script: error: $error\n" );
        }
        else
        {
            verbose( 9, "precompiling script: succeeded\n" );
        }
        $pass->src_cb($func);
    }

    verbose( 9, "splitting from args: $args\n" );
    my @argv;
    while ($args)
    {
        redo
            if $args =~
            s|^\s*(-[a-zA-Z0-9]\S*)|push(@argv, unquotearg($1)), ''|egis;
        redo
            if $args =~
            s|^\s*"(.*?(?!\\).)"|push(@argv, unquotearg($1)), ''|egis;
        redo if $args =~ s|^\s*'([^']*)'|push(@argv, $1), ''|egis;
        redo if $args =~ s|^\s*(\S+)|push(@argv, unquotearg($1)), ''|egis;
        redo if $args =~ s|^\s+$|''|egis;
    }
    verbose( 9, "splitting to argv: " . join( "|", @argv ) . "\n" );

    verbose( 9, "running script\n" );
    my $rc = $pass->src_cb->(@argv);
    $rc //= '';
    verbose( 9, "running script: rc=$rc\n" );
    $rc = 256 if not defined $rc;

    return $rc;
}

package WML::WML_F::PassesManager;

use Class::XSAccessor ( accessors => +{ map { $_ => $_ } qw( _passes ) } );

sub new
{
    my $self = bless +{}, shift;
    my $__PASSES = shift;
    $self->_passes(
        [
            '',
            map {
                WML::WML_F::PassObj->new(
                    idx => ( $_ + 1 ),
                    cb  => $__PASSES->[$_]
                    )
                }
                keys @$__PASSES

        ]
    );
    return $self;
}

sub pass
{
    my ( $self, $i ) = @_;

    return $self->_passes->[$i];
}

*verbose = \&::verbose;

sub dosystem
{
    my ( $self, $cmd ) = @_;
    verbose( 2, "system: $cmd\n" );
    return scalar system($cmd);
}

package main;

my $_pass_mgr = WML::WML_F::PassesManager->new(
    [
        \&pass1, \&pass2, \&pass3, \&pass4, \&pass5,
        \&pass6, \&pass7, \&pass8, \&pass9
    ]
);

my $VERSION = '@WML_VERSION@';

my $bindir = '@bindir@';
if ( index( $ENV{PATH}, $bindir ) < 0 )
{
    $ENV{PATH} = "$bindir:$ENV{PATH}";
}

use Getopt::Long 2.13;
use File::Spec ();
use Term::ReadKey qw/ ReadMode ReadKey /;
use Cwd ();

use IO::All qw/ io /;

sub _my_cwd
{
    my $cwd = Cwd::cwd;
    $cwd =~ s#/\z##;
    return $cwd;
}

sub ctime
{
    my ($time) = @_;
    return scalar( localtime($time) );
}

sub isotime
{
    my ($time) = @_;

    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) =
        localtime($time);
    return sprintf(
        "%04d-%02d-%02d %02d:%02d:%02d",
        $year + 1900,
        $mon + 1, $mday, $hour, $min, $sec
    );
}

sub gmt_ctime
{
    my ($time) = @_;
    return scalar( gmtime($time) );
}

sub gmt_isotime
{
    my ($time) = @_;

    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) =
        gmtime($time);
    return sprintf(
        "%04d-%02d-%02d %02d:%02d:%02d",
        $year + 1900,
        $mon + 1, $mday, $hour, $min, $sec
    );
}

sub usage
{
    my ($progname) = @_;

    print STDERR <<"EOF";
Usage: $progname [options] [inputfile]

Input Options:
  -I, --include=PATH      adds an include directory
  -i, --includefile=PATH  pre-include a particular include file
  -D, --define=NAME[=STR] define a variable
  -D, --define=NAME~PATH  define an auto-adjusted path variable
  -n, --noshebang         no shebang-line parsing (usually used by WMk)
  -r, --norcfile          no .wmlrc files are read
  -c, --nocd              read .wmlrc files without changing to input file directory

Output Options:
  -O, --optimize=NUM      specify the output optimization level
  -o, --outputfile=PATH   specify the output file(s)
  -P, --prolog=PATH       specify one or more prolog filters
  -E, --epilog=PATH       specify one or more epilog filters
  -t, --settime           sets mtime of outputfile(s) to mtime+1 of inputfile

Processing Options:
  -M, --depend[=OPTIONS]  dump dependencies as gcc does
  -p, --pass=STR          specify which passed should be run
  -W, --passoption[=PASS,OPTIONS]
                          set options for a specific pass
  -s, --safe              don't use precompile/inline hacks to speedup processing
  -v, --verbose[=NUM]     verbose mode
  -q, --quiet             quiet mode

Giving Feedback:
  -V, --version[=NUM]     display version and build information
  -h, --help              display this usage summary

EOF
    exit(1);
}

my $opt_h = 0;

#   pre-process argument line for option -r and -v
my $opt_r = 0;
my $opt_c = 0;

#   reset with defaults (except $opt_r and $opt_v)
my @opt_I = ();
my @opt_i = ();
my @opt_D = ();
my $opt_n = 0;
my $opt_O = '';
my @opt_o = ();
my @opt_P = ();
my @opt_E = ();
my $opt_t = 0;
my @opt_p = ();
my @opt_W = ();
my $opt_M = '-';
my $opt_s = 0;
my $opt_q = 0;
my $opt_V = -1;

sub ProcessOptions
{
    local $SIG{__WARN__} = sub {
        print STDERR "WML:Error: $_[0]";
    };
    $Getopt::Long::bundling      = 1;
    $Getopt::Long::getopt_compat = 0;
    my %list_options = (
        "I|include=s@"     => \@opt_I,
        "i|includefile=s@" => \@opt_i,
        "D|define=s@"      => \@opt_D,
        "o|outputfile=s@"  => \@opt_o,
        "P|prolog=s@"      => \@opt_P,
        "E|epilog=s@"      => \@opt_E,
        "p|pass=s@"        => \@opt_p,
        "W|passoption=s@"  => \@opt_W,
    );
    my %scalar_options = (
        "r|norcfile"   => \$opt_r,
        "n|noshebang"  => \$opt_n,
        "c|nocd"       => \$opt_c,
        "O|optimize=i" => \$opt_O,
        "t|settime"    => \$opt_t,
        "M|depend:s"   => \$opt_M,
        "s|safe"       => \$opt_s,
        "v|verbose:i"  => \$opt_v,
        "q|quiet"      => \$opt_q,
        "V|version:i"  => \$opt_V,
        "h|help"       => \$opt_h,
    );
    if ( not Getopt::Long::GetOptions( %scalar_options, %list_options ) )
    {
        warn "Try `$0 --help' for more information.\n";
        exit(0);
    }
    usage($0) if ($opt_h);
    while ( my ( $opt, $var ) = each(%list_options) )
    {
        if ( @$var and $var->[0] =~ m|^=| )
        {
            my $arg = substr( $opt, 0, 1 );
            warn "An equal sign has been detected after the `-$arg' option\n";
            warn "Try `$0 --help' for more information.\n\n";
            exit(0);
        }
    }
}

my @ARGVLINE = @ARGV;
ProcessOptions();
my $src = $ARGV[0];
@ARGV = @ARGVLINE;

#   reset with defaults (except $opt_r and $opt_v)
@opt_D = ();
@opt_i = ();
@opt_D = ();
$opt_n = 0;
$opt_O = '';
@opt_o = ();
@opt_P = ();
@opt_E = ();
$opt_t = 0;
@opt_p = ();
@opt_W = ();
$opt_M = '-';
$opt_s = 0;
$opt_q = 0;
$opt_V = -1;

#   save argument line
@ARGVLINE = @ARGV;
@ARGV     = ();

#   helper function to split argument line
#   the same way Bourne-Shell does:
#   #1: foo=bar quux   => "foo=bar", "quux"
#   #2: "foo=bar quux" => "foo=bar quux"
#   #3: foo="bar quux" => "foo=bar quux"     <-- !!
sub split_argv
{
    my ($str)  = @_;
    my (@argv) = ();
    my ($r)    = '';
    my ($prev) = '';

SPLIT_ARGV: while (1)
    {
        $prev = $str;
        if (   $str =~ s#\A"([^"\\]*(?:\\.[^"\\]*)*)"#$r .= $1;''#e
            or $str =~ s#\A'([^'\\]*(?:\\.[^'\\]*)*)'#$r .= $1;''#e
            or $str =~ s#\A([^\s"']+)#$r .= $1;''#e )
        {
            next SPLIT_ARGV;
        }
        if ( $str =~ /\A[\s\n]/ or $str eq '' )
        {
            if ( $r ne '' )
            {
                push( @argv, $r );
                $r = '';
            }
            $str =~ s#\A[\s\n]+##;
            last if ( $str eq '' );
        }
        if ( $str eq $prev )
        {
            #    breaks an infinite loop
            print STDERR "** WML:Error: options can not be correctly parsed\n";
            exit(1);
        }
    }
    return @argv;
}

sub CanonPath
{
    my ($path) = @_;

    my $pathL = '';
    while ( $path ne $pathL )
    {
        $pathL = $path;
        $path =~ s|//|/|g;
        $path =~ s|/\./|/|g;
        $path =~ s|/\.$|/|g;
        $path =~ s|^\./(.)|$1|g;
        $path =~ s|([^/.][^/.]*)/\.\.||;
    }
    return $path;
}

#   escape options if not quoted but
#   when shell metachars exists
sub quotearg
{
    my ($arg) = @_;
    if ( $arg !~ m|^'.*'$| )
    {
        if ( $arg =~ m|[\$"`]| )
        {
            $arg =~ s|([\$"`])|\\$1|sg;
        }
    }
    return $arg;
}

#   1. process options in WMLOPTS variable
if ( my $opts = $ENV{WMLOPTS} )
{
    verbose( 2, "Reading WMLOPTS variable" );
    $opts =~ s|^\s+||;
    $opts =~ s|\s+$||;

    #   arguments are not quoted because shell metacharacters
    #   have already been expanded, but dollar sign must be
    #   escaped
    $opts =~ s|\$|\\\$|g;
    @ARGV = split_argv($opts);
    ProcessOptions();
}

##
##  .wmlrc File Parsing
##
if ( not $opt_r )
{
    my $savedir = '';
    my @DIR     = ();

    #   First save current directory and go to input file directory
    if ( not $opt_c and $src =~ m|/| )
    {
        $src =~ s|/+[^/]*$||;
        if ( -d $src )
        {
            $savedir = Cwd::cwd;
            chdir($src);
        }
    }
    $src = '' if not $savedir;

    #   2. add all parent dirs .wmlrc files for options
    my $cwd = _my_cwd;
    while ($cwd)
    {
        push( @DIR, $cwd );
        $cwd =~ s|/[^/]+$||;
    }

    #   Restore directory
    chdir($savedir) if $savedir;

    #   3. add ~/.wmlrc file for options
    my @pwinfo = getpwuid($<);
    my $home   = $pwinfo[7];
    $home =~ s|/$||;
    if ( -f "$home/.wmlrc" )
    {
        push( @DIR, $home );
    }

    #   now parse these RC files
    foreach my $dir ( reverse(@DIR) )
    {
        if ( -f "$dir/.wmlrc" )
        {
            verbose( 2, "Reading RC file: $dir/.wmlrc\n" );
            open( my $wml_rc_fh, '<', "$dir/.wmlrc" )
                or error("Unable to load $dir/.wmlrc: $!");
            @ARGV = ();
        WMLRC_LINES:
            while ( my $l = <$wml_rc_fh> )
            {
                if ( $l =~ m|\A\s*\n?\z| or $l =~ m|\A\s*#[#\s]*.*\z| )
                {
                    next WMLRC_LINES;
                }
                $l =~ s|\A\s+||;
                $l =~ s|\s+\z||;
                $l =~ s|\$([A-Za-z_][A-Za-z0-9_]*)|$ENV{$1}|ge;
                push( @ARGV, split_argv($l) );
            }
            close($wml_rc_fh) || error("Unable to close $dir/.wmlrc: $!");
            my @opt_D_OLD = @opt_D;
            my @opt_I_OLD = @opt_I;
            @opt_D = ();
            @opt_I = ();
            ProcessOptions();
            my @opt_D_NEW = @opt_D_OLD;
            my @opt_I_NEW = @opt_I_OLD;

            #   adjust -D options
            my $reldir = File::Spec->abs2rel( "$dir", "$src" );
            $reldir = "." if $reldir eq '';
            foreach my $d (@opt_D)
            {
                if ( $d =~ m|^([A-Za-z0-9_]+)~(.+)$| )
                {
                    my ( $var, $path ) = ( $1, $2 );
                    if ( $path !~ m|^/| )
                    {
                        if ( $path eq '.' )
                        {
                            $path = CanonPath("$reldir");
                        }
                        else
                        {
                            $path = CanonPath("$reldir/$path");
                        }
                    }
                    $path = '""' if ( $path eq '' );
                    $d = "$var=$path";
                    push( @opt_D_NEW, $d );
                    next;
                }
                elsif ( $d =~ m|^([A-Za-z0-9_]+)$| )
                {
                    $d = $d . '=1';
                }
                push( @opt_D_NEW, $d );
            }

            #   adjust -I options
            $reldir = File::Spec->abs2rel("$dir");
            $reldir = "." if $reldir eq '';
            foreach my $path (@opt_I)
            {
                if ( $path !~ m|^/| )
                {
                    if ( $path eq '.' )
                    {
                        $path = CanonPath("$reldir");
                    }
                    else
                    {
                        $path = CanonPath("$reldir/$path");
                    }
                    $path = '.' if ( $path eq '' );
                }
                push( @opt_I_NEW, $path );
            }

            @opt_D = @opt_D_NEW;
            @opt_I = @opt_I_NEW;
        }
    }

}

#   4. process the command line options
@ARGV = @ARGVLINE;
my @opt_D_OLD = @opt_D;
@opt_D = ();    # extra remember -D options from command line
ProcessOptions();

my @opt_D_ADD;

#   quote the characters the shell have escaped
foreach my $d (@opt_D)
{
    push( @opt_D_ADD, quotearg($d) );
}
@opt_D = @opt_D_OLD;

#   fix the version level
if ( $opt_V == 0 )
{
    $opt_V = 1;    # Getopt::Long sets 0 if -V only
}
if ( $opt_V == -1 )
{
    $opt_V = 0;    # we operate with 0 for not set
}
if ($opt_V)
{
    print STDERR "This is WML Version $VERSION\n";
    print STDERR "Copyright (c) 1996-2001 Ralf S. Engelschall.\n";
    print STDERR "Copyright (c) 1999-2001 Denis Barbier.\n";
    print STDERR "\n";
    print STDERR
        "This program is distributed in the hope that it will be useful,\n";
    print STDERR
        "but WITHOUT ANY WARRANTY; without even the implied warranty of\n";
    print STDERR
        "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n";
    print STDERR "GNU General Public License for more details.\n";

    if ( $opt_V > 1 )
    {
        print STDERR <<'EOF';
Built Environment:
    Host: @built_system@
    Perl: @perlvers@ (@perlprog@)
    User: @built_user@
    Date: @built_date@
Built Location:
    Prefix: @prefix@
    BinDir: @bindir@
    LibDir: @libdir@
    ManDir: @mandir@
EOF
    }
    if ( $opt_V > 2 )
    {
        print STDERR "\n";
        print STDERR "Used Perl System:\n";
        my $perlprog = '@perlprog@';
        print STDERR `$perlprog -V`;
    }
    exit(0);
}

#   If the -M was the last option and the user forgot
#   to put `--' to end options, we adjust it.
if ( $opt_M !~ m%^(-|[MD]*)$% and ( !@ARGV ) )
{
    push( @ARGV, $opt_M );
    $opt_M = '';
}

#   set the input file
$src = $ARGV[0];

#   if no inputfile is given, WML reads from stdin
#   and forces quiet mode
if ( $src eq '' )
{
    $src   = '-';
    $opt_q = 1;
}

my $tmpdir = $ENV{TMPDIR} || '/tmp';

#   if input is stdin we create a temporary file
my $src_istmp = 0;
if ( $src eq '-' )
{
    $src_istmp = 1;
    $src       = "$tmpdir/wml.input.$$.tmp";
    unlink($src);
    open( my $tmp_fh, '>', $src )
        or error("Unable to write into $src: $!");
    while ( my $l = <STDIN> )
    {
        $tmp_fh->print($l)
            or error("Unable to write into $src: $!");
    }
    close($tmp_fh)
        or error("Unable to close $src: $!");
}

if ( not $src_istmp and not -f $src )
{
    print STDERR "** WML:Error: input file `$src' not found\n";
    exit(1);
}

#   now adjust -D options from command line
#   relative to path to source file
my ($reldir);
if ( not $src_istmp )
{
    $reldir = $src;
    $reldir =~ s,(:?/|^)[^/]+$,,;
    my $cwd = _my_cwd;
    $reldir = File::Spec->abs2rel( $cwd, "$cwd/$reldir" );
    $reldir = "." if $reldir eq '';
}
else
{
    $reldir = '.';
}
foreach my $d (@opt_D_ADD)
{
    if ( my ( $var, $path ) = $d =~ m|^([A-Za-z0-9_]+)~(.+)$| )
    {
        if ( $path !~ m|^/| )
        {
            if ( $path eq '.' )
            {
                $path = CanonPath($reldir);
            }
            else
            {
                $path = CanonPath("$reldir/$path");
            }
        }
        $path = '""' if ( $path eq '' );
        $d = "$var=$path";
    }
    elsif ( $d =~ m|^([A-Za-z0-9_]+)$| )
    {
        $d .= '=1';
    }
    push( @opt_D, $d );
}

#   5. process the options from the pseudo-shebang line
if ( not $opt_n )
{
    open( my $tmp_fh, '<', $src )
        or error("Unable to load $src: $!");
    my $shebang = '';
SHEBANG:
    while ( my $l = <$tmp_fh> )
    {
        $shebang .= $l;
        if ( $shebang !~ s/\\\s*\z//s )
        {
            last SHEBANG;
        }
    }
    close($tmp_fh)
        or error("Unable to close $src: $!");
    if ( $shebang =~ m|^#!wml\s+(.+\S)\s*$|is )
    {
        #   split opts into arguments and process them
        @ARGV = split_argv($1);
        ProcessOptions();
    }
}

#   6. expand %DIR and %BASE in the -o flags
my @opt_o_OLD = @opt_o;
@opt_o = ();
foreach my $opts (@opt_o_OLD)
{
    my ( $dir, $base );

    if ( $src =~ m|^(.+)/([^/]+)$| )
    {
        ( $dir, $base ) = ( $1, $2 );
    }
    else
    {
        ( $dir, $base ) = ( '.', $src );
    }
    $base =~ s|\.[a-zA-Z0-9]+$||;
    $opts =~ s|%DIR|$dir|sg;
    $opts =~ s|%BASE|$base|sg;
    push( @opt_o, $opts );
}

#   7. Undefine variables when requested
my %new_opt_D;
foreach my $d (@opt_D)
{
    if ( my ( $var, $val ) = ( $d =~ m|^(.+?)=(.*)$| ) )
    {
        if ( $val eq 'UNDEF' )
        {
            delete $new_opt_D{$var};
        }
        else
        {
            $new_opt_D{$var} = $val;
        }
    }
}
@opt_D = map { $_ . "=" . $new_opt_D{$_} } keys %new_opt_D;

#   fix the verbose level
if ( $opt_v == 0 )
{
    $opt_v = 1;    # Getopt::Long sets 0 if -v only
}
if ( $opt_v == -1 )
{
    $opt_v = 0;    # we operate with 0 for not set
}

sub error
{
    my ($str) = @_;
    print STDERR "** WML:Error: $str\n";
    exit(1);
}

my $PROTECT_COUNTER = 0;
my %PROTECT_STORAGE;

my $firstpass = 1;

sub protect
{
    my ( $fn, $pass ) = @_;
    my ( $prolog, $arg, $body, $key, $pe );

    my $data = io->file($fn)->all;
    open my $fp, '>', $fn
        or error("Unable to write into $fn for protection: $!");

    #   First remove a shebang line
    if ( $firstpass and $data =~ m/^#!wml/ )
    {
        while ( $data =~ s/^[^\n]*\\\n//s ) { 1; }
        $data =~ s/^[^\n]*\n//s;
    }

    #   Following passes will pass through previous test
    $firstpass = 0 if $firstpass;

    #  This loop must take care of nestable <protect> tags
    while ( $data =~ s|^(.*)<protect(.*?)>(.*?)</protect>||is )
    {
        my $passes_str = '123456789';
        ( $prolog, $arg, $body ) = ( $1, $2, $3 );

        #    unquote the attribute
        $arg =~ s|(['"])(.*)\1\s*$|$2|;
        if ( $arg =~ m|pass=([0-9,-]*)|i )
        {
            $passes_str = $1;
            $passes_str =~ s|,||g;
            $passes_str = "1$passes_str" if $passes_str =~ m|^-|;
            $passes_str .= '9' if $passes_str =~ m|-$|;
            $passes_str =~ s|([0-9])-([0-9])|expandrange($1, $2)|sge;
        }
        $pe = join( '', sort { $a <=> $b } ( split( '', $passes_str ) ) );
        $pe =~ s/^.*([0-9])$/$1/;
        $key = sprintf( "%06d", $PROTECT_COUNTER++ );
        $PROTECT_STORAGE{$key} = {
            SPEC => $passes_str,
            MAX  => $pe,
            ARG  => $arg,
            BODY => $body
        };
        $data = $prolog . "-=P[$key]=-" . $data;
    }

    #   And now unprotect passes
    while ( $data =~ s|^(.*?)-=P\[([0-9]+)\]=-||s )
    {
        $key = $2;
        $fp->print($1) || error("Unable to write into $fn for protection: $!");
        if ( $PROTECT_STORAGE{$key}->{SPEC} =~ m/$pass/ )
        {
            $fp->print("-=P[$key]=-")
                || error("Unable to write into $fn for protection: $!");
        }
        else
        {
            $data =
                  "<protect"
                . $PROTECT_STORAGE{$key}->{ARG} . ">"
                . $PROTECT_STORAGE{$key}->{BODY}
                . "</protect>"
                . $data;
        }
    }
    $fp->print($data) || error("Unable to write into $fn for protection: $!");
    $fp->close() || error("Unable to close ${fn}: $!");
}

sub unprotect
{
    my ( $fn, $pass ) = @_;
    use Carp;

    my $data = io->file($fn)->all;
    while ( my ( $prefix, $key, $new ) =
        $data =~ m|^(.*?)-=P\[([0-9]+)\]=-(.*)$|s )
    {
        $data = $new;
        if ( $pass < 9 and $pass < $PROTECT_STORAGE{$key}->{MAX} )
        {
            $prefix .= "<protect" . $PROTECT_STORAGE{$key}->{ARG} . ">";
            $data = "</protect>" . $data;
        }
        $data = $prefix . $PROTECT_STORAGE{$key}->{BODY} . $data;
    }

    #    Remove useless <protect> tags
    $data =~ s|</?protect.*?>||gs if $pass == 9;
    io->file($fn)->print($data);
    if ( $pass < 9 )
    {
        foreach my $key ( keys %PROTECT_STORAGE )
        {
            $PROTECT_STORAGE{$key} = undef;
        }
    }
}

my $libdir = '@libdir@';

sub pass1
{
    my ( $opt, $from, $to, $tmp ) = @_;
    return _generic_do( 1, 'wml_p1_ipp', $opt, $from, $to );
}

sub pass2
{
    my ( $opt, $from, $to, $tmp ) = @_;
    my ( $buf, $rc );

    my $cwd = _my_cwd;
    $rc = $_pass_mgr->dosystem(
        "$libdir/exec/wml_p2_mp4h $opt -I '$cwd' $from >$tmp");

    #   remove asterisks which can be entered
    #   by the user to avoid tag interpolation
    open( my $tmp_fh, '<', $tmp )
        or error("Unable to load $tmp: $!");
    open( my $to_fh, '>', $to )
        or error("Unable to write into $to: $!");
    {
        local $/;
        $buf = <$tmp_fh>;
    }
    $buf =~ s|<\*?([a-zA-Z][a-zA-Z0-9-_]*)\*?([^a-zA-Z0-9-_])|<$1$2|sg;
    $buf =~ s|<\*?(/[a-zA-Z][a-zA-Z0-9-_]*)\*?>|<$1>|sg;
    $to_fh->print($buf)
        or error("Unable to write into $to: $!");

    close($tmp_fh) || error("Unable to close $tmp: $!");
    close($to_fh)  || error("Unable to close $to: $!");

    return $rc;
}

sub pass3
{
    my ( $opt, $from, $to, $tmp ) = @_;

    return
        scalar $_pass_mgr->dosystem(
        "$libdir/exec/wml_p3_eperl $opt -P -k -B '<:' -E ':>' $from >$to");
}

sub pass4
{
    my ( $opt, $from, $to, $tmp ) = @_;

    return scalar $_pass_mgr->dosystem("m4 $opt --prefix-builtins <$from >$to");
}

sub pass5
{
    my ( $opt, $from, $to, $tmp ) = @_;
    return _generic_do( 5, 'wml_p5_divert', $opt, $from, $to );
}

sub pass6
{
    my ( $opt, $from, $to, $tmp ) = @_;
    return _generic_do( 6, 'wml_p6_asubst', $opt, $from, $to );
}

sub pass7
{
    my ( $opt, $from, $to, $tmp ) = @_;
    return _generic_do( 7, 'wml_p7_htmlfix', $opt, $from, $to );
}

sub pass8
{
    my ( $opt, $from, $to, $tmp ) = @_;
    return _generic_do( 8, 'wml_p8_htmlstrip', $opt, $from, $to );
}

#   Flag set if some output goes to stdout
my $out_istmp = 0;

sub pass9
{
    my ( $opt, $from, $to, $tmp ) = @_;

    #   First check whether a shebang line is found and no
    #   output files were assigned on command line.
    #   This is needed to unprotect output files.
    if ( !@opt_o )
    {
        local @ARGV = ();
        open( my $slice_fh, '<', $from )
            or error("Unable to load $from: $!");
        while ( my $l = <$slice_fh> )
        {
            if ( $l =~ m|%!slice\s+(.*)$| )
            {
                push( @ARGV, split_argv($1) );
            }
        }
        close($slice_fh)
            or error("Unable to close $from: $!");
        if (@ARGV)
        {
            $out_istmp = 0;
            ProcessOptions();
            ProcessOutfiles();
            $opt = $_pass_mgr->pass(9)->opt_pass;
        }
    }

    #   slice contains "package" commands and
    #   other stuff, so we cannot source it.
    return scalar $_pass_mgr->dosystem("$libdir/exec/wml_p9_slice $opt $from");
}

sub _generic_do
{
    my ( $pass_idx, $EXE, $opt, $from, $to ) = @_;
    my $prog = "$libdir/exec/$EXE";
    my $args = "$opt -o $to $from";
    return scalar(
          $opt_s
        ? $_pass_mgr->dosystem("$prog $args")
        : $_pass_mgr->pass($pass_idx)->dosource( $prog, $args )
    );
}

#
#   predefine some useful variables
#

my @pwinfo = getpwuid($<);

my $gen_username = $pwinfo[0];
$gen_username =~ s|[\'\$\`\"]||g;    # make safe for shell interpolation
$gen_username ||= 'UNKNOWN-USERNAME';

my $gen_realname = $pwinfo[6];
$gen_realname =~ s|^([^\,]+)\,.*$|$1|;
$gen_realname =~ s|[\'\$\`\"]||g;    # make safe for shell interpolation
$gen_realname ||= 'UNKNOWN-REALNAME';

my $gen_hostname = `hostname`;
$gen_hostname =~ s|\n$||;
$gen_hostname ||= 'UNKNOWN-HOSTNAME';

if ( $gen_hostname =~ m|^[a-zA-Z0-9_-]+$|
    and -f "/etc/resolv.conf" )
{
    my $domain = '';
    open( my $tmp_fh, '<', '/etc/resolv.conf' )
        or error("Unable to load /etc/resolv.conf: $!");
RESOLV_LOOP:
    while ( my $l = <$tmp_fh> )
    {
        if ( my ($new_domain) = $l =~ m|\Adomain\s+\.?(\S+)| )
        {
            $domain = $new_domain;
            last RESOLV_LOOP;
        }
    }
    close($tmp_fh)
        or error("Unable to close /etc/resolv.conf: $!");
    if ( $domain ne '' )
    {
        $gen_hostname = "$gen_hostname.$domain";
    }
}
my $gen_time        = time();
my $gen_ctime       = ctime( time() );
my $gen_isotime     = isotime( time() );
my $gen_gmt_ctime   = gmt_ctime( time() );
my $gen_gmt_isotime = gmt_isotime( time() );

my $cwd = _my_cwd;
my (
    $src_dirname,     $src_filename, $src_basename, $src_suffix,
    $src_time,        $src_ctime,    $src_isotime,  $src_gmt_ctime,
    $src_gmt_isotime, $src_username, $src_realname,
);

if ($src_istmp)
{
    $src_dirname     = $cwd;
    $src_filename    = 'STDIN';
    $src_basename    = 'STDIN';
    $src_suffix      = '';
    $src_time        = $gen_time;
    $src_ctime       = $gen_ctime;
    $src_isotime     = $gen_isotime;
    $src_gmt_ctime   = $gen_gmt_ctime;
    $src_gmt_isotime = $gen_gmt_isotime;
    $src_username    = $gen_username;
    $src_realname    = $gen_realname;
}
else
{
    if ( $src =~ m|/| )
    {
        $src_dirname = $src;
        $src_dirname =~ s|/+[^/]*$||;
        $src_dirname = Cwd::abs_path($src_dirname);
    }
    else
    {
        $src_dirname = $cwd;
    }
    $src_filename = $src;
    $src_filename =~ s|^.*/+||;
    $src_basename = $src_filename;
    $src_basename =~ s|(\.[a-zA-Z0-9]+)$||;
    $src_suffix = $1;
    my (
        $dev,  $ino,   $mode,  $nlink, $uid,     $gid, $rdev,
        $size, $atime, $mtime, $ctime, $blksize, $blocks
    ) = stat($src);
    $src_time        = $mtime;
    $src_ctime       = ctime($mtime);
    $src_isotime     = isotime($mtime);
    $src_gmt_ctime   = gmt_ctime($mtime);
    $src_gmt_isotime = gmt_isotime($mtime);
    my @pwinfo = getpwuid($uid);
    $src_username = $pwinfo[0] || 'UNKNOWN-USERNAME';
    $src_username =~ s|[\'\$\`\"]||g;    # make safe for shell interpolation
    $src_realname = $pwinfo[6] || 'UNKNOWN-REALNAME';
    $src_realname =~ s|^([^\,]+)\,.*$|$1|;
    $src_realname =~ s|[\'\$\`\"]||g;    # make safe for shell interpolation
}

unshift( @opt_D,
    "WML_SRC_DIRNAME=$src_dirname",
    "WML_SRC_FILENAME=$src_filename",
    "WML_SRC_BASENAME=$src_basename",
    "WML_SRC_TIME=$src_time",
    "WML_SRC_CTIME=$src_ctime",
    "WML_SRC_ISOTIME=$src_isotime",
    "WML_SRC_GMT_CTIME=$src_gmt_ctime",
    "WML_SRC_GMT_ISOTIME=$src_gmt_isotime",
    "WML_SRC_USERNAME=$src_username",
    "WML_SRC_REALNAME=$src_realname",
    "WML_GEN_TIME=$gen_time",
    "WML_GEN_CTIME=$gen_ctime",
    "WML_GEN_ISOTIME=$gen_isotime",
    "WML_GEN_GMT_CTIME=$gen_gmt_ctime",
    "WML_GEN_GMT_ISOTIME=$gen_gmt_isotime",
    "WML_GEN_USERNAME=$gen_username",
    "WML_GEN_REALNAME=$gen_realname",
    "WML_GEN_HOSTNAME=$gen_hostname",
    'WML_LOC_PREFIX=@prefix@',
    "WML_LOC_BINDIR=$bindir",
    "WML_LOC_LIBDIR=$libdir",
    'WML_LOC_MANDIR=@mandir@',
    "WML_VERSION=$VERSION",
    "WML_TMPDIR=$tmpdir" );

#   Create temporary file names as soon as $src_suffix is set
my @tmp = ( map { sprintf( "%s/wml.%s.tmp%d", $tmpdir, $$, $_ + 1 ) } 0 .. 3 );

#
#   generate options
#

#   canonicalize -p option(s)
if ( !@opt_p )
{
    #   no option means all passes
    @opt_p = ('1-9');
}
if ( not -s $src )
{
    #   on empty input optimize to just use pass 9
    @opt_p = ('9');
}
my $pass_str = join( '', @opt_p );
$pass_str =~ s|,||g;

sub expandrange
{
    my ( $s, $e ) = @_;
    my $x = '';
    for my $i ( $s .. $e )
    {
        $x .= $i;
    }
    return $x;
}

$pass_str =~ s|([0-9])-([0-9])|expandrange($1, $2)|sge;
my @passes_indices;
if ( $pass_str =~ s/!$// )
{
    @passes_indices = split( '', $pass_str );
}
else
{
    @passes_indices = sort { $a <=> $b } ( split( '', $pass_str ) );
}

#   only pre-processing if -M option specified
@passes_indices = ('1') if $opt_M ne '-';

#   determine includes
my $inc = '';
foreach my $i (@opt_I)
{
    $inc .= " -I $i";
}

#   determine preloads
my $preload = '';
foreach my $pass_idx (@passes_indices)
{
    $preload .= " -s 'sys/bootp${pass_idx}.wml'"
        if -f "$libdir/include/sys/bootp${pass_idx}.wml"
        and $pass_idx =~ m/^[34]$/;
}
foreach my $i (@opt_i)
{
    if ( $i =~ m|^<(.+)>$| )
    {
        $preload .= " -s '$1'";
    }
    else
    {
        $preload .= " -i '$i'";
    }
}

#   determine prologs
my $prolog = join '', map { ' -P "' . quotearg($_) . '"' } @opt_P;
my $defipp = '';
my $dummy;
foreach my $d (@opt_D)
{
    if ( my ( $var, $dummy, $val ) = ( $d =~ m|^(.+?)=("?)(.*)\2\n*$| ) )
    {
        $defipp .= " \"-D$var=$val\"";
    }
}
$defipp .= " -M$opt_M" if $opt_M ne '-';
$defipp .= " -DIPP_SRC_REALNAME=$src_filename" if not $src_istmp;

my $defmp4h = '';
foreach my $d (@opt_D)
{
    if ( my ( $var, $dummy, $val ) = ( $d =~ m|^(.+?)=("?)(.*)\2\n*$| ) )
    {
        $defmp4h .= " -D $var=\"$val\"";
    }
}
my $cnt = 0;
foreach my $o (@opt_o)
{
    $defmp4h .= " -D SLICE_OUTPUT_FILENAME[$cnt]=\"$o\"" if $o =~ m|\*|;
    ++$cnt;
}

my $defeperl = '';
foreach my $d (@opt_D)
{
    my ( $var, $dummy, $val ) = ( $d =~ m|^(.+?)=("?)(.*)\2\n*$| );
    $defeperl .= " \"-d$var=$val\"";
}

my $defgm4 = '';
foreach my $d (@opt_D)
{
    my ( $var, $dummy, $val ) = ( $d =~ m|^(.+?)=("?)(.*)\2\n*$| );
    $defgm4 .= " \"-Dm4_$var=$val\"";
}

my @out_filenames;

my $out = '';

sub ProcessOutfiles
{
    my ($o);

    $out           = '';
    @out_filenames = ();
    foreach my $o (@opt_o)
    {
        next if ( $o =~ m|\*[^:]*$| );

        #   create option
        if ( $o eq '-' )
        {
            $out .= " -o '" . quotearg( $tmp[3] ) . "'";
            $out_istmp = 1;
        }
        elsif ( $o =~ m/(.*):-$/ )
        {
            $out .= " -o '" . quotearg( $1 . ':' . $tmp[3] ) . "'";
            $out_istmp = 1;
        }
        else
        {
            $out .= " -o '" . quotearg($o) . "'";
        }

        #   unquote the filename
        $o =~ s|^(['"])(.*)\1$|$2|;

        #   create output file list for epilog filters
        if ( $o =~ m|^([_A-Z0-9~!+u%n\-\\^x*{}()@]+):(.+)\@(.+)$| )
        {
            push( @out_filenames, ( $2 ne '-' ? $2 : $tmp[3] ) );
        }
        elsif ( $o =~ m|^([_A-Z0-9~!+u%n\-\\^x*{}()@]+):(.+)$| )
        {
            push( @out_filenames, ( $2 ne '-' ? $2 : $tmp[3] ) );
        }
        elsif ( $o =~ m|^(.+)\@(.+)$| )
        {
            push( @out_filenames, ( $1 ne '-' ? $1 : $tmp[3] ) );
        }
        else
        {
            push( @out_filenames, ( $o ne '-' ? $o : $tmp[3] ) );
        }
    }
}
ProcessOutfiles();

my $verbose = '';
if ( $opt_v >= 3 )
{
    $verbose = '-v';
}

my $optimize = '';
if ( $opt_O ne '' )
{
    $optimize = "-O$opt_O";
}

my ( $from, $to );
if ( not $src_istmp )
{
    io->file( $tmp[0] )->print( io->file($src)->all );
    $from = $tmp[0];
    $to   = $tmp[1];
    $cnt  = 1;
}
else
{
    $from = $src;
    $to   = $tmp[0];
    $cnt  = 0;
}

if ( $out eq '' )
{
    $out       = " -o$tmp[3]";
    $out_istmp = 1;
}

my @_OPT_PASSES = (
    "$defipp $verbose -S $libdir/include -n $src $inc $preload $prolog",
    "$defmp4h", "$defeperl", "$defgm4", "$verbose", "$verbose", "$verbose",
    "$verbose $optimize",
    "$verbose $out",
);

while ( my ( $i, $str ) = each @_OPT_PASSES )
{
    $_pass_mgr->pass( $i + 1 )->opt_pass($str);
}

my $pcnt  = 0;
my @prop  = ( "-", "\\", "|", "/" );
my $last  = '';
my $pager = ( $ENV{PAGER} || 'more' );

#
#   clear out any existing CGI environments because some of our
#   passes (currently Pass 2 and 3) get totally confused by these
#   variables.
#
delete @ENV{
    qw(
        SERVER_SOFTWARE SERVER_NAME GATEWAY_INTERFACE SERVER_PROTOCOL
        SERVER_PORT REQUEST_METHOD PATH_INFO PATH_TRANSLATED SCRIPT_NAME
        QUERY_STRING REMOTE_HOST REMOTE_ADDR AUTH_TYPE REMOTE_USER REMOTE_IDENT
        CONTENT_TYPE CONTENT_LENGTH HTTP_ACCEPT HTTP_USER_AGENT
        )
};

sub unlink_tmp
{
    unlink( $tmp[0] );
    unlink( $tmp[1] );
    unlink( $tmp[2] );
    unlink( $tmp[3] );
    unlink($src) if ($src_istmp);
}

if ( $opt_M ne '-' )
{
    if (@out_filenames)
    {
        my $o = '"' . join( ' ', @out_filenames ) . '"';
        my $opt_pass = '';
        foreach my $aa (@opt_W)
        {
            if ( $aa =~ m|^([0-9]),(.*)$| )
            {
                $opt_pass .= " $2 " if $1 == 1;
            }
        }
        my $rc;
        eval {
            $rc = pass1( $_pass_mgr->pass(1)->opt_pass() . $opt_pass,
                $src, $o, $tmp[2] );
        };
        if ( $rc != 0 )
        {
            if ( $rc % 256 != 0 )
            {
                printf( STDERR
                        "** WML:Break: Error in Pass %d (status=%d, rc=%d).\n",
                    1, $rc % 256, $rc / 256 );
            }
            else
            {
                printf( STDERR "** WML:Break: Error in Pass %d (rc=%d).\n",
                    1, $rc / 256 );
            }
            unlink_tmp();
            exit(1);
        }
    }
    unlink_tmp();
    exit(0);
}

#
#   MAIN PROCESSING LOOP
#
my $final = 0;
PASS_IDX: foreach my $pass_idx (@passes_indices)
{
    verbose( 2, "PASS $pass_idx:\n" );
    print STDERR $prop[ $pcnt++ % 4 ] . "\b" if ( not $opt_q );

    #   run pass
    my ( $u, $s, $cu, $cs ) = times();
    my $stime = $u + $s + $cu + $cs;
    protect( $from, $pass_idx );
    my $opt_pass = '';
    foreach my $aa (@opt_W)
    {
        if ( my ( $pp, $s ) = $aa =~ m|\A([0-9]),(.*)\z| )
        {
            $opt_pass .= " $s " if $pp == $pass_idx;
        }
    }
    my $_pass = $_pass_mgr->pass($pass_idx);
    my $rc =
        $_pass->cb()->( $_pass->opt_pass() . $opt_pass, $from, $to, $tmp[2] );
    if ( !length($rc) )
    {
        $rc = 0;
    }
    if ( $rc != 0 )
    {
        if ( $rc % 256 != 0 )
        {
            printf( STDERR
                    "** WML:Break: Error in Pass %d (status=%d, rc=%d).\n",
                $pass_idx, $rc % 256, $rc / 256 );
        }
        else
        {
            printf( STDERR "** WML:Break: Error in Pass %d (rc=%d).\n",
                $pass_idx, $rc / 256 );
        }
        unlink_tmp();
        exit(1);
    }

    # pass 9 is a special case
    unprotect( $to, $pass_idx ) if ( $pass_idx < 9 );
    ( $u, $s, $cu, $cs ) = times();
    my $etime = $u + $s + $cu + $cs;
    my $dtime = $etime - $stime;
    $dtime = 0.01 if ( $dtime < 0 );
    $_pass->time_($dtime);

    #   optionally view current result
    if (0)
    {
        if ( $opt_v >= 3 && $pass_idx < 9 )
        {
            print STDERR "Want to see result after Pass$pass_idx [yNq]: ";
            ReadMode 4;
            my $key = ReadKey(0);
            ReadMode 0;
            print STDERR "\n";
            if ( $key =~ m|[Yy]| )
            {
                system("$pager $to");
            }
            elsif ( $key =~ m|[qQ]| )
            {
                printf( STDERR "** WML:Break: Manual Stop.\n" );
                unlink_tmp();
                exit(1);
            }
        }
    }

    #   step further
    $last = $to;
    $final = 1 if $pass_idx == 9;
    my $bit = ( $cnt & 1 );
    $from = $tmp[$bit];
    $to   = $tmp[ $bit ^ 1 ];
    unlink($to);
    ++$cnt;

    if ($final)
    {
        last PASS_IDX;
    }
}

if ( $last ne '' and $final and $out_istmp )
{
    unprotect( $tmp[3], 9 );
}
elsif ( $last ne '' and not $final )
{
    my $i  = 0;
    my @fh = ();
    my $fp;
    unprotect( $last, 9 );
    if (@out_filenames)
    {
        foreach my $o (@out_filenames)
        {
            open $fh[$i], '>', $o or error("Unable to write into $o");
            ++$i;
        }
    }
    else
    {
        my $o = $tmp[3];
        open $fh[$i], '>', $o or error("Unable to write into $o");
    }
    open( my $fp_fh, '<', $last )
        or error("Unable to load $last: $!");
    while ( my $l = <$fp_fh> )
    {
        foreach my $fp (@fh)
        {
            $fp->print($l)
                or error("Unable to write into output file: $!");
        }
    }
    foreach my $fp (@fh)
    {
        $fp->close() or error("Unable to close output file: $!");
    }
    close($fp_fh) || error("Unable to close $last: $!");
}

#   Unprotect output files and run epilog filters
if (@out_filenames)
{
    #   unprotect all outputfiles
    foreach my $o (@out_filenames)
    {
        unprotect( $o, 9 );
    }

    #   optionally set mtime of outputfiles
    #   to mtime of inputfile if inputfile was not STDIN
    if ( not $src_istmp and $opt_t )
    {
        my (
            $dev,  $ino,   $mode,  $nlink, $uid,     $gid, $rdev,
            $size, $atime, $mtime, $ctime, $blksize, $blocks
        ) = stat($src);
        $atime = time();
        foreach my $o (@out_filenames)
        {
            utime( $atime, $mtime + 1, $o );
        }
    }

    #   run epilog filters
    foreach my $o (@out_filenames)
    {
        foreach my $e (@opt_E)
        {
            if ( $e =~ m|^htmlinfo(.*)| )
            {
                $e = "$libdir/exec/wml_aux_htmlinfo$1";
            }
            elsif ( $e =~ m|^linklint(.*)| )
            {
                $e = "$libdir/exec/wml_aux_linklint$1";
                $e .= " -nocache -one -summary" if ( $1 eq '' );
            }
            elsif ( $e =~ m|^weblint(.*)| )
            {
                $e = "$libdir/exec/wml_aux_weblint$1";
            }
            elsif ( $e =~ m|^tidy(.*)| )
            {
                $e = "tidy$1";
                $e .= ' -m' if ( $1 eq '' );
            }
            verbose( 2, "EPILOG: $e $o\n" );
            my $rc = system("$e $o");

            #   Tidy returns 1 on warnings and 2 on errors :(
            $rc = 0
                if ( $rc == 256
                and index( $e, "$libdir/exec/wml_aux_tidy" ) >= 0 );
            error("epilog failed: $e $o") if $rc != 0;
        }
    }
}

#   ... and eventually send to stdout
if ($out_istmp)
{
    io->file( $tmp[3] ) > io('-');
}

unlink_tmp();

my ( $u, $s, $cu, $cs ) = times();
my $at      = $u + $s + $cu + $cs;
my $pt      = 0;
my $timestr = '';

foreach my $i ( 1 .. 9 )
{
    my $t = $_pass_mgr->pass($i)->time_() // '';
    if ( length($t) )
    {
        $pt += $t;
    }
    my $cond = ( $i == 2 or $i == 3 );
    $timestr .= (
          ( $t ne '' ) ? sprintf( $cond ? '%5.2f' : '%4.2f', $t )
        : $cond        ? '   -- '
        :                '  -- '
    );
}

$timestr = sprintf( '%4.2f | ', $at - $pt ) . $timestr;
$timestr .= sprintf( '| %6.2f', $at );
verbose( 1, "Processing time (seconds):\n" );
verbose( 1,
    "main |  ipp  mp4h   epl  gm4  div asub hfix hstr slic |  TOTAL\n" );
verbose( 1,
    "---- | ---- ----- ----- ---- ---- ---- ---- ---- ---- | ------\n" );
verbose( 1, "$timestr\n" );

#   exit gracefully
exit(0);

##EOF##
__END__

=head1 NAME

WML - Website META Language

=head1 VERSION

@WML_VERSION@

=head1 SYNOPSIS

B<wml>
[B<-I> I<PATH>]
[B<-i> I<PATH>]
[B<-D> I<NAME>B<=>I<STR>]
[B<-D> I<NAME>B<~>I<PATH>]
[B<-n>]
[B<-r>]
[B<-O> I<level>]
[B<-o> [I<SLICETERM>C<:>]I<PATH>[B<@>I<CHMODOPT>]]
[B<-P> I<PATH>]
[B<-E> I<PATH>]
[B<-t>]
[B<-p> I<STR>]
[B<-W> I<STR>]
[B<-s>]
[B<-v> [I<NUM>]]
[B<-q>]
[I<inputfile>]

B<wml>
[B<-V> [I<NUM>]]
[B<-h>]

=head1 DESCRIPTION

This is the control program of the I<Website META Language> (WML), a free HTML
generation toolkit for Unix, internally consisting of 9 independent languages.

The main idea of WML is a sequential filtering scheme where each language
provides one of 9 processing passes.  So F<wml> reads I<inputfile> (or from
F<stdin> if I<inputfile> is a dash or completely missing), applies passes 1-9
(or only the passes specified by B<-p>) and finally produces one or more
I<outputfile>s.

For more details on this processing scheme read the I<WML Introduction> under
wml_intro(7) and the I<WML Tutorial> under wml_tutorial(7).

=head1 OPTIONS

=over

=item B<-I>, B<--include=>I<PATH>

Adds a I<directory> to the list of user include paths. Use this option to set the
runtime environment for pass 1. See wml_p1_ipp(1) for more details.

=item B<-i>, B<--includefile=>I<PATH>

Pre-loads a particular include I<file>, i.e. virtually adds a

  #include "PATH"

at the top of I<inputfile>. Use this to automatically include default user
include files. If you want to include a systems include file you have to
surround the I<PATH> with angle brackets, for instance use ``C<-i>
C<"E<lt>foo/bar.wmlE<gt>">'' to include the file F<foo/bar.wml> from the
system include area.  Alternatively you can use the special syntax
``C<wml::foo::bar>'' as with the C<#use> directive.

=item B<-D>, B<--define=>I<NAME>B<=>I<STR>

Defines a variable which can be interpolated in pass 1 (IPP) via C<$(NAME)>, in
pass 2 (mp4h) via E<lt>C<get-var NAME>E<gt>, in pass 3 (ePerl) via
C<E<lt>:=$NAME:E<gt>> and in pass 4 (GNU m4) via C<m4_NAME>.
A special variant B<--define=>I<NAME>B<=UNDEF> does the opposite, it
deletes previous definitions (which may be different than undefining
these variables, e.g. with system defined variables).

=item B<-D>, B<--define=>I<NAME>B<~>I<PATH>

Similar to the above but defines a variable holding a pathname which is
autoadjusted (see below).  It can be interpolated in the same ways as the
C<NAME=STR> variant from above.

=item B<-n>, B<--noshebang>

This forces WML to ignore a possibly contained shebang line in I<inputfile>.
This is usually used by WMk, because WMk already parsed this line and supplied
the options to WML.

=item B<-r>, B<--norcfile>

This forces WML to ignore all F<.wmlrc> files.

=item B<-c>, B<--nocd>

When WML processes an input file from another directory, it jumps into
that directory before parsing F<.wmlrc> files, and jump back to current
directory after.  If this option is set, no directory change is made and
F<.wmlrc> files are read reative to current working directory.

=item B<-O>, B<--optimize=>I<NUM>

This is the optimization option which is passed directly to pass 8
(F<htmlfix>). It controls the amount of optimization/stripping which is
applied to the generated HTML markup code.

=item B<-o>, B<--outputfile=>I<SLICETERM>B<:>I<outputfile>[B<@>I<CHMODOPT>]

This redirects the output to a file. Usually the whole file will be send to
F<stdout> (same as C<ALL:->). You can use this option more than once to output
to more than one file while using the I<SLICETERM> as a set theory term of
slices to determine which contents will be included into each particular
output file.  The optional I<CHMODOPT> is intended for specifying options for
a finally applied F<chmod> command. For instance use ``C<u+x>'' to create a
file with the execution bit set (Apache's XBitHack feature).
See wml_p9_slice(1) for more details.

=item B<-P>, B<--prolog=>I<PATH>

Runs an prolog filter over the input file.  This program receives the data to
act on as STDIN and has to produce the filtered data on STDOUT.

=item B<-E>, B<--epilog=>I<PATH>

Runs an epilogue program over the finally resulting output files.  Currently
the following WML-specific programs are known: F<htmlinfo>, F<linklint>,
F<tidy> and F<weblint>.  But you can specify any program which is available in
your C<PATH>. This program receives the file to act on as its first command
line argument. Notice that output is not redirected to this file, so you have
to use a wrapper or program specific flags if you want to modify output files.

=item B<-t>, B<--settime>

This sets the modification time of all output files to the modification time
of I<intputfile> plus 1 second. This is useful because Webservers will
generate C<Last-Modified> headers and there the editing time is more important
than the generation time. The 1 second offset is for the dependencies
of Makefiles.

=item B<-M>, B<--depend>[B<=>I<OPTIONS>]

Output a rule suitable for `make' describing the dependencies of each output
file, as `gcc' does. It has only sense when the B<-o> option is used.
No processing is done except for the first pass.

The B<D> flag option writes the rule to a dependency file. The name of
this file is obtained by replacing the suffix of the output file by ".d".

The B<M> flag option deletes the system files from the list of dependencies.

=item B<-p>, B<--pass=>I<STR>

Specifies which of the passes described above are actually applied under
runtime. The argument I<STR> is a comma-separated list of pass numbers with
one special case: You can write C<X-Y> for all passes C<X...Y>.  When pass 9
is not part of I<STR> the resulting output is written to F<STDOUT>. Default is
the string ``C<1-9>''.

=item B<-W>, B<--passoption=>I<NUM>,I<STR>

Set option I<STR> for the pass I<NUM>.

=item B<-s>, B<--safe>

This disables some Perl hacks inside WML which speedup processing by reducing
the forking overhead when running the various passes.

Without this option WML pre-compiles the passes 1,5,6,7,8 (which are written
in Perl!) into a different namespace of the currently running Perl interpreter
instead of running them externally via C<system()>. The effect is that these
programs are run from within the same Perl interpreter thus saving five CPU-
and time-intensive C<fork()>'s. The actual gain is between 2 and 4 seconds of
processing time. Although experience showed that it works great, the
theoretical problem still is, that this approach is somewhat risky due to
internal Perl variable conflicts.

Use this option to disable these speedups by forcing WML to use the safe
C<fork()> approach.

=item B<-v>, B<--verbose>[B<=>I<NUM>]

This sets verbose mode (from 1 to 9) where some processing information will be
given on the console. Useful for debugging. This option also gets passed to
some of the filtering programs. Default is no verbosity and just B<-v> means
B<-v1>.

=item B<-q>, B<--quiet>

This sets quiet mode where the processing prop is no longer displayed.  Use
this option when running F<wml> as a batch job.  This option is automatically
forced when I<inputfile> is missing.  Then WML automatically reads from
F<stdin> in quiet mode.

=item B<-V>, B<--version>[B<=>I<NUM>]

Gives the version identification string and disclaimer (no I<NUM> or I<NUM>
E<gt>= 1), the WML build information (I<NUM> E<gt>= 2) and the Perl build
information (I<NUM> E<gt>= 3). Use this option to get a brief description of
your installed WML system, especially when reporting bugs to the author.

=item B<-h>, B<--help>

Prints the usage summary page.

=back

=head1 ENVIRONMENT

=head2 DEFINED VARIABLES

The following variables are always defined by F<wml> under runtime and are
usually interpolated via E<lt>C<get-var NAME>E<gt> inside Pass 2 and via
C<$NAME> in Pass 3.

=over 4

=item WML_SRC_DIRNAME

The current working directory from where F<wml> was started.
An absolute Unix filesystem path.

=item WML_SRC_FILENAME

The name of the I<inputfile> from the command line. Useful when running F<wml>
on a bulk of files and includefiles have to determine in which they are
included.

=item WML_SRC_BASENAME

The basename of the I<inputfile>, i.e. the C<WML_SRC_FILENAME>, but with the
extension already stripped.

=item WML_SRC_TIME

The last modification time of I<inputfile> in C<time()> format.
Useful inside footers when customized date format is needed.

=item WML_SRC_CTIME

The last modification time of I<inputfile> in C<ctime()> format.
Useful inside footers include files.

=item WML_SRC_ISOTIME

The last modification time of I<inputfile> in ISO C<yyyy-mm-dd hh:mm:ss> format.
Useful inside footers include files.

=item WML_SRC_USERNAME

The Unix username of the user who own I<inputfile>.

=item WML_SRC_REALNAME

The realname of the user who own I<inputfile>.

=item WML_GEN_TIME

The current time of generation in C<time()> format.
Useful inside footers when customized date format is needed.

=item WML_GEN_CTIME

The current time of generation in C<ctime()> format.
Useful inside footers include files.

=item WML_GEN_ISOTIME

The current time of generation in ISO C<yyyy-mm-dd hh:mm:ss> format.
Useful inside footers include files.

=item WML_GEN_USERNAME

The Unix username of the user who runs the F<wml> process.

=item WML_GEN_REALNAME

The realname of the user who runs the F<wml> process.

=item WML_GEN_HOSTNAME

The name of the host on which the F<wml> command runs.

=item WML_LOC_PREFIX

The location prefix where WML was installed to at built time.

=item WML_LOC_BINDIR

The directory where WML's binaries were installed to at built time.

=item WML_LOC_LIBDIR

The directory where WML's library files were installed to at built time.

=item WML_LOC_MANDIR

The directory where WML's manual pages were installed to at built time.

=item WML_VERSION

The version identification string of WML.  Use this for instance in HTML
comments inside header includes to identify the generation tools version.

=back

=head2 USED VARIABLES

=over 4

=item C<WMLOPTS>

This variable can contain a string of options.  Usually this is used by
Bourne-Shell users like

  $ WMLOPTS="-DNAME1=VALUE2 -DNAME2=VALUE2"
  $ export WMLOPTS

and by C-Shell users like

  $ setenv WMLOPTS "-DNAME1=VALUE2 -DNAME2=VALUE2"

to make sure some variables are defined for all runs of F<wml>.

=item C<PAGER>

This variable contains the pager WML is to use. WML uses a pager when
called with the B<--verbose=>I<NUM> or B<-v>I<NUM> option respectively and
I<NUM> is 3 or higher and therefore showing the processed data after
each pass.  Default is 'more'.

=item C<TMPDIR>

This variable contains the directory WML stores its temporary files in.
Default is '/tmp'.

=back

=head1 USER FILES

=over 4

=item F<$HOME/.wmlrc> and F<(../)*.wmlrc>

These files can also contain option strings, one option per line.  Usually the
contents is one or more B<-D> options, especially auto-adjusted ones:

  -DROOTREL~.
  -DROOTABS=http://thishost/thisarea/
     :
  -DNAME1=VALUE1
  -DNAME2=VALUE2
     :

=back

=head1 STANDARD INCLUDE FILES

WML is shipped with a standard set of include files.
You can directly include them via

  #use wml::category::name

and read their own documentation via

  $ man wml::category::name

See wml::all(3) for a description of all available include files.

=head1 SPECIAL FEATURES

The WML control frontend provides a few special features on its own:

=over 4

=item Shebang Line Support

WML recognizes a I<shebang> line (``C<#!wml> I<options>'') in the F<.wml>
files and automatically adds I<options> to its command line. This line is also
used by WMk. Two special features in contrast to shebang lines for the Unix
loader are available: WML's shebang line can be continued via a backslash
character and the constructs C<%DIR> and %<BASE> are interpolated (where
C<%DIR> is the path to the directory the source while resides and C<%BASE> is
the filename of the source file without any extension).

Example:

  #!wml -o (ALL-LANG_*)+LANG_EN:%BASE.en.html \
        -o (ALL-LANG_*)+LANG_DE:%BASE.de.html

=item Data Protection Container Tag

WML provides an own internal container tag named C<E<lt>protect
[pass=SPEC]E<gt>>...C<E<lt>/protectE<gt>> which can be used to protect any type
of data from being processed by any WML pass. When no C<pass> attribute is
given I<SPEC> defaults to C<1-9>. When you use C<pass> then I<SPEC> can be
either C<#->, C<-#>, C<#-#> or a comma separated list of passes, while
C<#> can be between C<1> and C<9>.

Example:

   <script language="JavaScript">
   <protect pass=2>
   ...
   output = "<PRE><DIV ALIGN=\"CENTER\"><B>" + help_string + "</B></DIV></PRE>"
   ...
   </protect>
   </script>

Warning:

Since WML 2.0.3, pass 1 includes extra stuff to help keeping information
about line numbers relevant (a la cpp).  So when writing

   <protect pass=2>
   #include 'foo'
   </protect>

these extra commands will not be interpreted during pass 2 and will
remain on output.  To suppress them, either compile with C<-W1,-N> flag,
or write

   <protect pass=2>
   #include 'foo' IPP_NOSYNCLINES
   </protect>

=back

=head1 AUTHORS

 Ralf S. Engelschall
 rse@engelschall.com
 www.engelschall.com

 Denis Barbier
 barbier@engelschall.com

=head1 SEEALSO

wmd(1),
wml_faq(7),
wml_intro(7),
wml_tutorial(7),
wml_tags(7),
wml::all(3).

=cut
# vim: ft=perl
